---
title: 2020 Nowcoder Basic Algorithm Training Camp Contest 2
description: 
published: true
date: 2020-08-13T04:43:38.303Z
tags: algorithm, contest, nowcoder, solution, acm
editor: markdown
---

# 2020 牛客寒假算法基础集训营 2

> 枚举、贪心、DP、数论、思维、数据结构、哈希

2A. 做游戏
------

### 大意

石头剪刀布。已知两人分别出了多少次石头、剪刀和布，求其中一个玩家最多能获胜多少局。

### 思路

贪心。让尽量多的剪刀 \- 布、石头 \- 剪刀和布 \- 石头成组，可以直接出答案 $min(A,Y)+min(B,Z)+min(C,X)$。

    #include <bits/stdc++.h>
    using namespace std;
    int main()
    {
        long long a, b, c, x, y, z;
        cin >> a >> b >> c >> x >> y >> z;
        cout << min(a, y) + min(b, z) + min(c, x) << endl;
        return 0;
    }

2B. 排数字
------

### 大意

给出一个字符串 $S$，问将字符串打乱后最多能有多少个不同的连续子串为 $616$ 。 

### 思路

只需将所有的 $6$ 和 $1$ 集中起来：$6161616...$ ，因此统计 $6$ 和 $1$ 的个数即可，得出答案。注意 $cnt6$ 个 $6$ 最多能只造 $cnt6-1$ 个满足题意的字串，所以是 $min(cnt6-1,cnt1)$。如果算出来小于零应该将答案调整为 $0$。

    #include <bits/stdc++.h>
    using namespace std;
    int main()
    {
        int n, cnt1 = 0, cnt6 = 0;
        string s;
        cin >> n >> s;
        for (int i = 0; i < n; i++)
        {
            if (s[i] == '1')
                cnt1++;
            else if (s[i] == '6')
                cnt6++;
        }
        cout << max(0, min(cnt6 - 1, cnt1)) << endl;
        return 0;
    }

2C. 算概率
------

### 大意

一共 $n$ 道题，第 $i$ 道题的正确率是 $p_i$​，给出这个正确率对 $10^9+7$ 取模的结果，求这 $n$ 题里恰好有 $0,1,\cdots,n$ 题正确的概率分别是多少，同样对 $10^9+7$ 取模。对分数取模的定义已在题目给出。

### 思路

简单 DP。一个难点是求状态转移方程，一个是理解题目中对分数取模的概念（本蒟蒻在补第四套题时才会的乘法逆元，做这道题时直接观察样例对 $\frac{1}{2}$ 取模的结果，然后分子分母代进 $a$ 和 $b$ 蒙一把，发现简单粗暴地将概率乘个 $(10^9+7)+1$ 就是了）。要求前 $i$ 题正确 $j$ 题的概率，首先要知道的是前面具体过了哪几道题我们不需要知道（这里有点靠直觉），我们只需要简单粗暴地把它当作一个整体参与后面的计算。接下来，我们要分两种情况讨论，一个是第 $i$ 题对了 $f_{i-1,j} \cdot p_i$，一个是第 $i$ 题错了 $f_{i,j} \cdot (1-p_i)$，加起来就是了。状态转移方程 $f_{i,j} = f_{i-1,j} \cdot p_i+f_{i-1,j} \cdot (1-p_i)$。

    #include <bits/stdc++.h>
    using namespace std;
    
    long long n, p[2005], dp[2005][2005];
    
    int main()
    {
        cin >> n;
        for (int i = 1; i <= n; i++)
        {
            cin >> p[i];
        }
        dp[0][0] = 1;
        for (int i = 1; i <= n; i++)
        {
            dp[i][0] = dp[i - 1][0] * (1000000008 - p[i]) % 1000000007;
            for (int j = 1; j <= i; j++)
                dp[i][j] = (dp[i - 1][j] * (1000000008 - p[i]) + dp[i - 1][j - 1] * p[i]) % 1000000007;
        }
        for (int i = 0; i <= n; i++)
            cout << dp[n][i] << ' ';
        return 0;
    }
    

2D. 数三角
------

### 大意

给出 $n$ 个点，问这 $n$ 个点形成的三角形中，总共有多少个钝角三角形。

### 思路

签到。枚举后比较 $a^2+b^2$ 和 $c^2$ 即可，另外注意三点不能共线。

    #include <bits/stdc++.h>
    using namespace std;
    
    int n, a[505], b[505], ans = 0;
    
    bool f(int i, int j, int k)
    {
        int check1 = (a[j] - a[i]) * (a[k] - a[i]) + (b[j] - b[i]) * (b[k] - b[i]);
        int check2 = (a[j] - a[i]) * (b[k] - b[i]) - (a[k] - a[i]) * (b[j] - b[i]);
        return check1 < 0 && check2 != 0;
    }
    int main()
    {
        cin >> n;
        for (int i = 0; i < n; i++)
            cin >> a[i] >> b[i];
        for (int i = 0; i < n; i++)
        {
            for (int j = i + 1; j < n; j++)
            {
                for (int k = j + 1; k < n; k++)
                {
                    if (f(i, j, k) || f(k, i, j) || f(j, i, k))
                    {
                        ans++;
                    }
                }
            }
        }
    
        cout << ans << endl;
        return 0;
    }

2E. 做计数
------

### 大意

求有多少个不同的正整数三元组 $(i,j,k)$ 满足 $\sqrt i+\sqrt j = \sqrt k$，而且 $i \cdot j \leq n$。

### 思路

看过一样的题，所以说多去看百度贴吧的营销号推送确实能涨知识。见到根号疯狂平方就对了（必要时候还是要移项的）。等式左右两边平方，$i+j+2 \sqrt {ij}=k$，发现要使 $k$ 为整数，必需要令 $i \cdot j$ 为完全平方数，所以我们就枚举完全平方数，然后再枚举这些完全平方数的因数。

    #include <bits/stdc++.h>
    using namespace std;
    int n, ans;
    int main()
    {
        cin >> n;
        for (int i = 1; i * i <= n; i++)
        {
            for (int j = 1; j <= i; j++)
                if (i * i % j == 0)
                    ans += 2;
            ans--;
        }
        cout << ans << endl;
        return 0;
    }

2F. 拿物品
------

### 大意

多个物品，每个物品两个属性 $a$ 和 $b$， 甲乙两人轮流拿物品，最后甲的得分为其拿到物品的 $a$ 属性的和，乙则为 $b$ 属性的和。问两人最优策略下会拿哪些物品。

### 思路

假设两人赛后互换物品 $(a_1,b_1)$ 和 $(a_2,b_2)$，那么两人得分变化分别为 $-a_1+a_2$ 和 $b_1-b_2$，如果想让前者得分更大，要有 $a_1+b_1 < a_2+b_2$。后者同理。所以就按照 $a+b$ 排序。

    #include <bits/stdc++.h>
    using namespace std;
    
    const int N = 2e5 + 7;
    int n;
    vector<int> sa, sb;
    struct temp
    {
        int a, b, id;
    } a[N];
    
    bool cmp(temp a, temp b)
    {
        return a.a + a.b > b.a + b.b;
    }
    
    int main()
    {
        cin >> n;
        for (int i = 1; i <= n; i++)
            cin >> a[i].a;
        for (int i = 1; i <= n; i++)
        {
            cin >> a[i].b;
            a[i].id = i;
        }
        sort(a + 1, a + 1 + n, cmp);
        for (int i = 1; i <= n; ++i)
            ((i & 1) ? sa : sb).push_back(a[i].id);
        for (auto i : sa)
            cout << i << " ";
        cout << endl;
        for (auto i : sb)
            cout << i << " ";
        cout << endl;
        return 0;
    }

2G. 判正误
------

### 大意

给出七个整数 $a, b, c, d, e, f, g$ 问是否有 $a^d+b^e+c^f=g$。数据范围 $10^9$ 级别，数据量 $10^3$ 级别。

### 思路

在模的意义下上快速幂验证，也就是验证 $a^d+b^e+c^f \equiv g \left ( mod \ M\right )$。模数越多，数据越水，就越稳。

    #include <bits/stdc++.h>
    using namespace std;
    const int mod[] = {2, 3, 5, 7, 11, 31, 71, 97, 233, 397, 433, 449, 607, 857, 10007, 21179, 36251, 44579, 62003, 72883, 97843, 139991, 232013, 369353, 681521, 692711, 777241, 822821, 1956761, 2145137, 2915837, 6229117, 7788787, 13743493, 17331841, 19260817, 19269293, 19959809, 21006959, 23937083, 24410849, 28452757, 28478603, 29229359, 35570827, 35604011, 35875487, 37370863, 38303347, 38475517, 38819149, 40455791, 44021539, 45641993, 46531301, 48866749, 50529641, 52634191, 52790587, 55180799, 56971613, 58259351, 60954737, 62207269, 63367453, 65072599, 66017821, 67952779, 69475349, 74689217, 77059907, 77907121, 79391659, 84768797, 85584601, 85724879, 85756609, 86850899, 91783511, 92331541, 94519499, 96375241, 99033413, 99486311, 100569829, 106873549, 109329881, 109913681, 111186487, 111894067, 112136617, 112417363, 114011921, 119143363, 122994493, 123747781, 124001021, 126515639, 128191039, 128767909, 132222763, 133587661, 139644719, 145641527, 153388423, 155187077, 156883333, 157989581, 159538063, 161488643, 164039129, 166070447, 169181543, 169554227, 173564801, 175742867, 185469637, 187203899, 191263223, 198691817, 204144887, 211631201, 217903877, 218028203, 220073423, 228143453, 228667423, 232064653, 240519263, 245647159, 247586411, 247936121, 250949197, 253413211, 253464329, 260572729, 260590409, 262887773, 265711423, 266763641, 273585149, 276472817, 276500531, 280543667, 280649591, 281385491, 291366337, 293273159, 296973107, 302890501, 306568693, 315614297, 316729409, 317617121, 320337781, 320613497, 321322823, 324691051, 325963067, 327184157, 329900633, 330670159, 332058781, 332213669, 332300869, 334382221, 341895677, 347938237, 349011827, 349347503, 349906439, 353796941, 364557253, 364755931, 367946441, 372413831, 374358983, 379589897, 381149689, 389431873, 404683493, 405216109, 405495029, 408142403, 408989747, 410841979, 410935093, 412405351, 412592459, 412722139, 412990573, 418171483, 421270357, 424233613, 427938449, 428492083, 429962881, 430883569, 434988383, 435941201, 438816151, 440052953, 440143589, 444693631, 453646433, 455847109, 456640189, 457911511, 458185237, 463116761, 463861417, 469275953, 471298573, 471712513, 478267417, 483824813, 494828483, 497397293, 499657393, 507957479, 512906621, 519346459, 519879973, 520094713, 523213693, 525673273, 529575763, 529883803, 533887031, 534260809, 535328309, 541992667, 542253071, 544780177, 545567609, 552922529, 555129893, 555820037, 558473471, 563484017, 571310471, 578121241, 582251063, 583825639, 584121323, 592038487, 599098811, 601467677, 610073969, 615059213, 619220713, 622457177, 627412609, 630547919, 632342989, 637357363, 638865419, 648268013, 650007487, 651564761, 654115433, 661281713, 662664461, 667914281, 682988213, 691099121, 691445809, 692038043, 692411953, 698620943, 699007259, 701164631, 706806461, 707096251, 707697451, 709566589, 719095829, 725756807, 736880491, 739603867, 743026709, 744236861, 744396049, 747393791, 749395103, 760341121, 762934307, 773124059, 773195911, 776162609, 781629113, 781884613, 786120631, 788314343, 788898377, 788939293, 790209983, 791933183, 796328783, 798643889, 802280047, 803293991, 803847559, 809752739, 818520473, 820434047, 826810489, 829359959, 829707427, 836587463, 841011167, 843763253, 849410557, 851226437, 853058471, 853168793, 853778327, 859086391, 860720017, 863193077, 873061181, 888803059, 893035529, 900902953, 904636883, 917949577, 921817139, 922328707, 931449133, 933074827, 933156233, 935241721, 935632799, 939948881, 957119773, 961329913, 965269573, 965337949, 967551691, 971080093, 973578143, 976825877, 985100197, 985413691, 986124823, 990650057, 998244353, 999058883, 1000000007};
    int ff(int a, int m)
    {
        return (a % m + m) % m;
    }
    int Pow(int a, int b, int c)
    {
        int ret = 1;
        while (b)
        {
            if (b & 1)
                ret = ret * 1ll * a % c;
            a = a * 1ll * a % c;
            b >>= 1;
        }
        return ret;
    }
    int a, b, c, d, e, f, g;
    
    bool check(int m)
    {
        return ((Pow(ff(a, m), d, m) + Pow(ff(b, m), e, m)) % m + Pow(ff(c, m), f, m)) % m == ff(g, m);
    }
    
    int main()
    {
        int T;
        cin >> T;
        while (T--)
        {
            cin >> a >> b >> c >> d >> e >> f >> g;
            bool flag = 1;
            for (int i = 0; i < 349; ++i)
            {
                if (!check(mod[i]))
                {
                    flag = 0;
                    break;
                }
            }
            puts(flag ? "Yes" : "No");
        }
        return 0;
    }